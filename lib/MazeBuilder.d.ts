import { MazeNode } from "./MazeNode";
import { Cardinality } from "./Behavior/Cardinality";
import { Maze } from "./Maze";
/**
 * @class MazeBuilder
 *
 * Instanceable builder class which generates randomized Mazes in their most basic form.  This class can be
 * extended to handle the creation of a specialized maze or a derivative thereof.
 */
export declare class MazeBuilder {
    /**
     * Complexity factor of the maze to be generated
     *
     * @type {number}
     */
    protected complexity: number;
    /**
     * The 'entry' point of the generated maze (will not be poplated until buildMaze() is run).
     *
     * @type {MazeNode}
     */
    protected entry: MazeNode;
    /**
     *  A Cardinality instance responsible for facilitating node connection and traversal
     *  logic.
     *
     *  @type {Cardinality}
     */
    cardinality: Cardinality;
    /**
     * The maze being generated by the builder
     */
    maze: Maze;
    /**
     * Constructor
     *
     * @param {Cardinality} cardinality
     * @param {number} complexity
     */
    constructor(cardinality?: Cardinality, complexity?: number);
    /**
     * Build a new randomized maze instance based on local instance configurations
     *
     * @returns {Maze}
     */
    buildMaze(): Maze;
    /**
     * Convenience function (static) for shorthand randomization.
     *
     * @TODO !BUG! max cannot be reached by this algorithm, but instead max - 1
     *
     * @param {number} max
     * @param {number} min
     * @returns {number}
     */
    static rand(max?: number, min?: number): number;
    /**
     * Generate a new random path sourcing from the indicated node.
     *
     * @param {MazeNode} pointer
     * @param {number} depth
     * @returns {MazeBuilder}
     */
    generateRandomPathFrom(pointer: MazeNode, depth?: number): MazeBuilder;
    /**
     * Builder will seek a random node within the defined parameters.  Once node is identified, it will branch
     * out a new randomized path of nodes.
     *
     * @param {MazeNode} startingNode
     * @param {number} maxDepth
     * @returns {MazeBuilder}
     */
    seekAndGenerateRandomPath(startingNode: MazeNode, maxDepth?: number): MazeBuilder;
    /**
     * Try every available connection point on the node and attempt to connect to a new or existing node.
     * Return the index of the successful connections connection point when new connection is made.
     * If no connection is made, returns -1.
     *
     * @param {MazeNode} pointer
     * @param {number[]} openConnectionPoints
     * @returns {number}
     */
    private attemptNodeConnectionFromEveryAvailableExit;
    /**
     * Convenience function to simply get the next node WHEN ALL EXIT POINTS ARE CLAIMED
     *
     * @pre  All exit points on the node must connect to other nodes.  Ignoring this precondition
     * may result in exceptions being thrown.
     *
     * @param {MazeNode} pointer
     */
    private hopToNextNodeInRandomDirection;
    /**
     * Finds out if there is a neighboring node at the indicated exit.  If a node is found, returns that node,
     * otherwise generates a new node and returns that.  Coordinates will be set on the node returned.
     *
     * @param {MazeNode} pointer
     * @param {number} exitPoint
     * @returns {MazeNode}
     */
    private getNextNodeAtExit;
    /**
     * Convenience method for producing or finding the next node at the given exitPoint.
     * If the next node has an available connection point for a logical connection to the supplied pointer,
     * the connection will be made between the supplied node and the next node.
     *
     * @param {MazeNode} pointer
     * @param {number} exitPoint
     * @returns {number}  If successful, the exit position on the supplied pointer, which leads to the adjoining node, will return.
     *                    Otherwise, -1 will be returned.
     */
    private attemptBuildNextNodeOnPath;
    /**
     * If the indicated dictionary has negative node values (a natural result of the current version of
     * the generation process), push all of the node coordinates up so that 0,0 represents the top left.
     *
     * This ultimately updates the map so that it will fit nicely within quadrant II of the cartesian graph.
     *
     * @returns {{[p: string]: MazeNode}}
     */
    private normalizeNodeCoordinates;
    /**
     * Get the size of each dimension of this maze (for example, if
     * width = 6 and length = 4, this function will return [6, 4]).
     *
     * @returns {number[]}
     */
    private getDimensions;
    /**
     * Select a random node on the existing maze.
     *
     * @returns {MazeNode}
     */
    private selectRandomNode;
}
