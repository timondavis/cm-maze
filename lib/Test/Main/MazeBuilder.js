"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
var chai_1 = require("chai");
var MazeBuilder_1 = require("../../MazeBuilder");
var Compass8_1 = require("../../Behavior/Compass8");
var Compass4_1 = require("../../Behavior/Compass4");
describe('MazeBuilder', function () {
    var MB;
    it('generates randomized mazes composed of randomly interconnected graph nodes', function () {
        MB = new MazeBuilder_1.MazeBuilder();
        var a = MB.buildMaze();
        var b = MB.buildMaze();
        var c = MB.buildMaze();
        var d = MB.buildMaze();
        var e = MB.buildMaze();
        var f = MB.buildMaze();
        chai_1.expect(a.getSize() + b.getSize() + c.getSize()).not.to.be.equal(d.getSize() + e.getSize() + f.getSize());
    });
    it('can enforce cardinality behaviors to all MazeNodes by applying an instance of CardinalityBehavior', function () {
        MB = new MazeBuilder_1.MazeBuilder(new Compass8_1.Compass8());
        var a = MB.buildMaze();
        chai_1.expect(a.getStartNode().getCardinality()).to.be.an.instanceOf(Compass8_1.Compass8);
        MB = new MazeBuilder_1.MazeBuilder(new Compass4_1.Compass4());
        var b = MB.buildMaze();
        chai_1.expect(b.getStartNode().getCardinality()).to.be.an.instanceOf(Compass4_1.Compass4);
    });
    it('facilitates integer randomization as a static convenience service', function () {
        var min = 0;
        var max = 3;
        var numbersFound = [false, false, false, false];
        for (var i = 0; i < 1000; i++) {
            chai_1.expect(function () { numbersFound[MazeBuilder_1.MazeBuilder.rand(max, min)] = true; }).not.to.throw();
        }
        for (var i = 0; i <= max; i++) {
            chai_1.expect(numbersFound[i]).to.be.true;
        }
    });
    it('will provide a coordinate collection of nodes generated by the build algorithm', function () {
        MB = new MazeBuilder_1.MazeBuilder();
        var maze = MB.buildMaze();
        chai_1.expect(Object.keys(MB.maze.getNodes())).to.have.length.greaterThan(0);
    });
    it('will never create a room with all exits sealed', function () {
        var mb4 = new MazeBuilder_1.MazeBuilder(new Compass4_1.Compass4(), 500);
        var mb8 = new MazeBuilder_1.MazeBuilder(new Compass8_1.Compass8(), 500);
        var maze4 = mb4.buildMaze();
        var maze8 = mb8.buildMaze();
        maze4.getNodesArray().forEach(function (node) {
            chai_1.expect(node.getAvailableConnectionPoints().length).to.be.greaterThan(0);
        });
        maze8.getNodesArray().forEach(function (node) {
            chai_1.expect(node.getAvailableConnectionPoints().length).to.be.greaterThan(0);
        });
    });
    // Tricky/expensive to prove without a search algorithm.  Will implement this on the official.  Mean while, these tests are pending.
    it('can generate a random path from a given node');
    it('can generate a random path from a random existing node (sourced from provided node)');
    // Has consistency issues.  Foregoing testing until solved.
    it('has a configurable complexity which determines the size, difficulty of maze');
});
