"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
var chai_1 = require("chai");
var MazeBuilder_1 = require("../../MazeBuilder");
var CardinalityBehaviorEight2D_1 = require("../../Behavior/CardinalityBehaviorEight2D");
var CardinalityBehaviorFour2D_1 = require("../../Behavior/CardinalityBehaviorFour2D");
describe('MazeBuilder', function () {
    var MB;
    it('generates randomized mazes composed of randomly interconnected graph nodes', function () {
        MB = new MazeBuilder_1.MazeBuilder();
        var a = MB.buildMaze();
        var b = MB.buildMaze();
        var c = MB.buildMaze();
        chai_1.expect(a.getSize()).not.to.be.equal(b.getSize());
        chai_1.expect(a.getSize()).not.to.be.equal(c.getSize());
        chai_1.expect(b.getSize()).not.to.be.equal(c.getSize());
    });
    it('can enforce cardinality behaviors to all MazeNodes by applying an instance of CardinalityBehavior', function () {
        MB = new MazeBuilder_1.MazeBuilder(new CardinalityBehaviorEight2D_1.CardinalityBehaviorEight2D());
        var a = MB.buildMaze();
        chai_1.expect(a.getStartNode().getCardinality()).to.be.an.instanceOf(CardinalityBehaviorEight2D_1.CardinalityBehaviorEight2D);
        MB = new MazeBuilder_1.MazeBuilder(new CardinalityBehaviorFour2D_1.CardinalityBehaviorFour2D());
        var b = MB.buildMaze();
        chai_1.expect(b.getStartNode().getCardinality()).to.be.an.instanceOf(CardinalityBehaviorFour2D_1.CardinalityBehaviorFour2D);
    });
    it('facilitates integer randomization as a static convenience service', function () {
        var min = 0;
        var max = 3;
        var numbersFound = [false, false, false, false];
        for (var i = 0; i < 1000; i++) {
            chai_1.expect(function () { numbersFound[MazeBuilder_1.MazeBuilder.rand(max, min)] = true; }).not.to.throw();
        }
        for (var i = 0; i <= max; i++) {
            chai_1.expect(numbersFound[i]).to.be.true;
        }
    });
    it('will provide a coordinate collection of nodes generated by the build algorithm', function () {
        MB = new MazeBuilder_1.MazeBuilder();
        var maze = MB.buildMaze();
        chai_1.expect(Object.keys(MB.getCoordinatesCollection())).to.have.length.greaterThan(0);
    });
    // Tricky/expensive to prove without a search algorithm.  Will implement this on the official.  Mean while, these tests are pending.
    it('can generate a random path from a given node');
    it('can generate a random path from a random existing node (sourced from provided node)');
    // Has consistency issues.  Foregoing testing until solved.
    it('has a configurable complexity which determines the size, difficulty of maze');
});
